const path = require("path");
const fs = require("fs").promises;

const { GoogleGenerativeAIEmbeddings, ChatGoogleGenerativeAI } = require('@langchain/google-genai');
const { WeaviateStore } = require('@langchain/weaviate');
const { PDFLoader } = require('@langchain/community/document_loaders/fs/pdf');
const { RecursiveCharacterTextSplitter } = require('@langchain/textsplitters');
const { default: supabase } = require("./supabase");
const weaviateLib = require('weaviate-client').default;

// --- Weaviate client ---
const WEAVIATE_HOST = process.env.WEAVIATE_HOST;
const WEAVIATE_API_KEY = process.env.WEAVIATE_API_KEY;


async function makeWeaviateClient() {
    console.time
    // The weaviate-client package exposes helper connectToWeaviateCloud in recent versions.
    // Fallback: instantiate raw client via weaviateLib.client({ scheme, host, apiKey: new ... })
    if (typeof weaviateLib.connectToWeaviateCloud === 'function') {
        const client = await weaviateLib.connectToWeaviateCloud(WEAVIATE_HOST, {
            authCredentials: new weaviateLib.ApiKey(WEAVIATE_API_KEY),
        });
        // optional: await client.connect() if required by client version
        return client;
    } else {
        // fallback manual client creation
        const client = weaviateLib.client({
            scheme: WEAVIATE_HOST.startsWith('https') ? 'https' : 'http',
            host: WEAVIATE_HOST.replace(/^https?:\/\//, ''),
            apiKey: new weaviateLib.ApiKey(WEAVIATE_API_KEY),
        });
        return client;
    }
}

const llm = new ChatGoogleGenerativeAI({
    modelName: process.env.GEMINI_CHAT_MODEL || 'models/gemini-2.5-flash-lite',
    model: process.env.GEMINI_CHAT_MODEL || 'models/gemini-2.5-flash-lite',
    apiKey: process.env.GOOGLE_API_KEY,
    // temperature: 0.2,
    // maxRetries: 2,
    // maxOutputTokens: 2048,
});

// --- Embeddings setup ---
const embeddings = new GoogleGenerativeAIEmbeddings({
    model: 'models/gemini-embedding-001',
    apiKey: process.env.GOOGLE_API_KEY,
    batchSize: 64 // ‚¨Ö 16-64 –±–æ–ª–≥–æ–æ—Ä–æ–π, –∏—Ö—ç–Ω—Ö–¥—ç—ç 4‚Äì5—Ö —Ö—É—Ä–¥–∞–Ω –±–æ–ª–¥–æ–≥

});

/**
 * PDF-–≥ ”©–≥—Å”©–Ω path-–∞–∞—Å —É–Ω—à–∏–∂, text-–≥ chunk —Ö–∏–π–∂, Weaviate-–¥ —Ö–∞–¥–≥–∞–ª–∞—Ö
 * @param {string} pdfPath PDF —Ñ–∞–π–ª—ã–Ω –∑–∞–º
 * @param {string} indexName Weaviate-–¥ –∞—à–∏–≥–ª–∞—Ö index/collection –Ω—ç—Ä
 */


async function ingestPdfToVectorDB(pdfPath, indexName = "default_books_index") {
    const client = await makeWeaviateClient()
    try {
        console.time(`Ingestion process for ${pdfPath}`);

        await fs.access(pdfPath);
        const pdfFileName = path.basename(pdfPath);
        console.log(`Processing PDF: ${pdfFileName}`);

        // 1. PDF-–≥ —É–Ω—à–∏—Ö
        console.time("1. Loading PDF");
        const loader = new PDFLoader(pdfPath);
        const rawDocs = await loader.load();
        console.timeEnd("1. Loading PDF");

        // 2. Text-–≥ chunk-“Ø“Ø–¥—ç–¥ —Ö—É–≤–∞–∞—Ö
        console.time("2. Splitting documents");
        const textSplitter = new RecursiveCharacterTextSplitter({
            chunkSize: 1000,
            chunkOverlap: 150,
        });
        const docs = await textSplitter.splitDocuments(rawDocs);
        console.log(`Split into ${docs.length} documents.`);
        console.timeEnd("2. Splitting documents");

        // x2 x3

        // 3. Metadata –Ω—ç–º—ç—Ö
        docs.forEach(doc => {
            doc.metadata.book_title = pdfFileName;
            doc.metadata.source_path = pdfPath;
            // 'loc.pageNumber' –±–∞–π—Ö–≥“Ø–π —Ç–æ—Ö–∏–æ–ª–¥–æ–ª–¥ –∞–ª–¥–∞–∞ –∑–∞–∞—Ö–∞–∞—Å —Å—ç—Ä–≥–∏–π–ª—ç—Ö
            doc.metadata.page_number = doc.metadata.loc?.pageNumber || 0;
        });

        // 4. Ensure Weaviate collection exists with proper schema
        console.time("3.1. Ensuring Weaviate schema");
        try {
            const collectionExists = await client.collections.exists(indexName);
            if (!collectionExists) {
                console.log(`Creating new Weaviate collection: ${indexName}`);
                await client.collections.create({
                    name: indexName,
                    properties: [
                        {
                            name: 'content',
                            dataType: ['text'],
                            description: 'The text content of the document chunk'
                        },
                        {
                            name: 'book_title',
                            dataType: ['text'],
                            description: 'Title of the source PDF'
                        },
                        {
                            name: 'page_number',
                            dataType: ['int'],
                            description: 'Page number in the PDF'
                        },
                        {
                            name: 'source_path',
                            dataType: ['text'],
                            description: 'File path of the PDF'
                        }
                    ],
                    vectorizer: 'none' // We provide embeddings manually
                });
                console.log(`‚úÖ Created collection: ${indexName}`);
            } else {
                console.log(`‚úÖ Collection already exists: ${indexName}`);
            }
        } catch (schemaErr) {
            console.error('‚ö†Ô∏è Schema check/create error (will try to continue):', schemaErr.message);
        }
        console.timeEnd("3.1. Ensuring Weaviate schema");

        // 4. Vector DB-–¥ —Ö–∞–¥–≥–∞–ª–∞—Ö
        console.time("3.2. Storing vectors to Weaviate");
        await WeaviateStore.fromDocuments(docs, embeddings, {
            client,
            indexName,
            textKey: 'content',
            metadataKeys: ['book_title', 'page_number', 'source_path'],
        });
        console.timeEnd("3.2. Storing vectors to Weaviate");

        console.log(`‚úÖ PDF '${pdfFileName}' vectors saved to Weaviate under index '${indexName}'`);
        console.timeEnd(`Ingestion process for ${pdfPath}`);
        return { ok: true, message: "Success", pdf: pdfFileName, indexName, docCount: docs.length };

    } catch (err) {
        console.error("‚ùå Error ingesting PDF:", err.stack || err.message);
        return { ok: false, error: err.message };
    }
}


async function askQuestion(query, indexName, bookName, conversation_group_id) {
    const client = await makeWeaviateClient();
    console.log({
        query, indexName, bookName, conversation_group_id
    })
    let conversationHistory = [

    ];

    if (conversation_group_id && (conversation_group_id + "").length > 0) {
        conversationHistory = await supabase.from("conversations").select("*").eq("conversation_group_id", conversation_group_id).order("created_time", {
            ascending: true
        }).limit(20).then(e => e.data)
    }

    try {
        console.time("Total question answering time");
        console.log(`Querying index '${indexName}' for book '${bookName}'`);
        const vectorStore = await WeaviateStore.fromExistingIndex(embeddings, {
            client,
            indexName: indexName,
            textKey: 'content',
            metadataKeys: ['book_title', 'page_number', 'source_path'],
        });

        // LangChain JS-–¥ –∑–æ—Ä–∏—É–ª—Å–∞–Ω where —Ñ–∏–ª—Ç–µ—Ä–∏–π–≥ –∞—à–∏–≥–ª–∞—Ö
        // –≠–Ω—ç –Ω—å –∑”©–≤—Ö”©–Ω —Ç—É—Ö–∞–π–Ω –Ω–æ–º—ã–Ω chunk-“Ø“Ø–¥—ç—ç—Å —Ö–∞–π–ª—Ç —Ö–∏–π–Ω—ç.
        const weaviateFilter = {
            operator: 'Equal',
            path: ['book_title'],
            valueText: bookName,
        };

        const retriever = vectorStore.asRetriever({
            k: 10,
            searchKwargs: {
                where: weaviateFilter // where —Ñ–∏–ª—Ç–µ—Ä –∞—à–∏–≥–ª–∞—Ö
            }
        });

        const qaSystemPrompt = `
CodeyGym AI ‚Äî –°—É—Ä–≥–∞–ª—Ç—ã–Ω –±–∞–≥—à–∏–π–Ω –¥“Ø—Ä—ç–º

“Æ“Ø—Ä—ç–≥ (Purpose)
–ß–∏ –±–æ–ª —Ç—ç–≤—á—ç—ç—Ä—Ç—ç–π, –º—ç–¥–ª—ç–≥—Ç—ç–π, –æ–π–ª–≥–æ–º–∂—Ç–æ–π AI –±–∞–≥—à. –ó–æ—Ä–∏–ª–≥–æ ‚Äî —Å—É—Ä–∞–≥—á–¥–∞–¥ —Ç—É—Ö–∞–π–Ω —Ö–∏—á—ç—ç–ª–∏–π–Ω –∞–≥—É—É–ª–≥–∞–¥ —Ç—É–ª–≥—É—É—Ä–ª–∞—Å–∞–Ω, –ª–æ–≥–∏–∫ –¥–∞—Ä–∞–∞–ª–∞–ª—Ç–∞–π, —Ç–æ–≤—á –±–æ–ª–æ–≤—á –±“Ø—Ä—ç–Ω —Ö–∞—Ä–∏—É–ª—Ç ”©–≥”©—Ö.

–•–∞—Ä–∏—É–ª–∞—Ö –∑–∞—Ä—á–∏–º

–ó”©–≤—Ö”©–Ω ”©–≥”©–≥–¥—Å”©–Ω —Ö–∏—á—ç—ç–ª–∏–π–Ω –º–∞—Ç–µ—Ä–∏–∞–ª –±–æ–ª–æ–Ω ”©–º–Ω”©—Ö —Ö–∞—Ä–∏–ª—Ü–∞–Ω —è—Ä–∏–∞–≥ (chat history) –∞—à–∏–≥–ª–∞–Ω —Ö–∞—Ä–∏—É–ª.

–•—ç—Ä—ç–≤ –∞—Å—É—É–ª—Ç—ã–Ω —Ö–∞—Ä–∏—É–ª—Ç —Ö–∏—á—ç—ç–ª–∏–π–Ω –º–∞—Ç–µ—Ä–∏–∞–ª–¥ –æ–ª–¥–æ—Ö–≥“Ø–π –±–æ–ª —è–≥ —Ç–æ–¥–æ—Ä—Ö–æ–π —Ç–∏–π–º —Ö—ç–ª—ç—ç—Ä —Ö—ç–ª: ‚Äú–≠–Ω—ç –º—ç–¥—ç—ç–ª—ç–ª —Ö–∏—á—ç—ç–ª–¥ –æ–ª–¥—Å–æ–Ω–≥“Ø–π.‚Äù
–î–∞—Ä–∞–∞ –Ω—å —Ç—É—Ö–∞–π–Ω —Å—ç–¥–≤–∏–π–Ω —Ö“Ø—Ä—ç—ç–Ω–¥ –æ–π–ª–≥–æ–º–∂—Ç–æ–π —Ç–∞–π–ª–±–∞—Ä, –∂–∏—à—ç—ç –±–æ–ª–æ–Ω —Ö—ç—Ä—ç–≥—Ç—ç–π –∑”©–≤–ª”©–º–∂ ”©–≥”©—Ö.

–•—É–¥–∞–ª –∑“Ø–π–ª –∑–æ—Ö–∏–æ–∂ –±–æ–ª–æ—Ö–≥“Ø–π. –ë–∞—Ä–∏–º—Ç–≥“Ø–π —Ç–∞–∞–º–∞–≥, —Ç–∞—à–∞–∞ –º—ç–¥—ç—ç–ª—ç–ª –±“Ø“Ø –Ω—ç–º.

–•–∞—Ä–∏—É–ª—Ç—ã–Ω –±“Ø—Ç—ç—Ü (—Ö–∞–º–≥–∏–π–Ω —ç—Ö—ç–Ω–¥—ç—ç—Å –¥–∞—Ä–∞–∞–ª–∞–ª—Ç–∞–π)

–¢–æ–≤—á —Ö–∞—Ä–∏—É–ª—Ç: –ì–æ–ª —Å–∞–Ω–∞–∞–≥ –Ω—ç–≥ —Ö–æ—ë—Ä –º”©—Ä—Ç –±–∞–≥—Ç–∞–∞–∂ ”©–≥.

–¢–∞–π–ª–±–∞—Ä / –ñ–∏—à—ç—ç: –ê–ª—Ö–∞–º –¥–∞—Ä–∞–∞–ª–∞–ª, –±–æ–≥–∏–Ω–æ –∂–∏—à—ç—ç–≥ –∞—à–∏–≥–ª–∞.

–î“Ø–≥–Ω—ç–ª—Ç / –î–∞—Ä–∞–∞–≥–∏–π–Ω –∞–ª—Ö–∞–º: –î–∞–≤—Ç–∞–∂, —Å—É—Ä–∞–≥—á–∏–¥ —é—É–≥ —Ö–∏–π—Ö–∏–π–≥ —Å–∞–Ω–∞–ª –±–æ–ª–≥–æ.

–ú—ç–Ω–¥—á–∏–ª–≥—ç—ç –±–∞ —Ö—ç–ª–Ω–∏–π —Ö—ç–≤ –º–∞—è–≥

–•—ç–ª–ª—ç–≥: –≠–µ–ª–¥—ç–≥, –æ–π–ª–≥–æ–º–∂—Ç–æ–π, —É—Ä–∞–º ”©–≥—Å”©–Ω.

–•—ç—Ä–≤—ç—ç ”©–º–Ω”©—Ö —Ö–∞—Ä–∏–ª—Ü–∞–Ω —è—Ä–∏–∞ –±–∞–π–≥–∞–∞ –±–æ–ª –º—ç–Ω–¥—á–∏–ª–≥—ç—ç–≥ –¥–∞–≤—Ç –±–∏—Ç–≥–∏–π —Ö—ç–ª.

–•“Ø—Å—Å—ç–Ω —Ç–æ—Ö–∏–æ–ª–¥–æ–ª–¥ emoji –∞—à–∏–≥–ª–∞–∂ –±–æ–ª–Ω–æ (–≥—ç—Ö–¥—ç—ç –∑–æ—Ö–∏–º–∂–≥“Ø–π –∏—Ö –±“Ø“Ø —Ö—ç—Ä—ç–≥–ª—ç).

–ë–∞—Ç–∞–ª–≥–∞–∞–∂—É—É–ª–∞–ª—Ç –±–æ–ª–æ–Ω —Å—É—Ä–∞–≥—á–∏–π–≥ —à–∞–ª–≥–∞—Ö –∞—Å—É—É–ª—Ç—É—É–¥

–•–∞—Ä–∏—É–Ω—ã—Ö–∞–∞ —Ç”©–≥—Å–≥”©–ª–¥ —Å—É—Ä–∞–≥—á–∏–π–≥ –æ–π–ª–≥–æ–ª—Ç–æ–æ —à–∞–ª–≥–∞—Ö —ç—Å–≤—ç–ª –±—ç–ª–¥—ç—Ö—ç–¥ —Ç—É—Å–ª–∞—Ö –∂–∏–∂–∏–≥ –∞—Å—É—É–ª—Ç—É –æ—Ä—É—É–ª:

‚Äú–≠–Ω–≥–∏–π–Ω—ç—ç—Ä —Ö—ç–ª–±—ç–ª ‚Äî ?‚Äù

‚Äú”®”©—Ä”©”©—Ä —Ç–∞–π–ª–±–∞—Ä–ª–∞–≤–∞–ª ‚Äî ?‚Äù

‚Äú–≠–Ω–¥ –∞—Å—É—É–ª—Ç –±–∞–π–Ω–∞ —É—É?‚Äù

–¢–µ—Ö–Ω–∏–∫–∏–π–Ω —Ç—ç–º–¥—ç–≥–ª—ç–ª

–ë“Ø—Ö —Ö–∞—Ä–∏—É–ª—Ç–∞–Ω–¥ “Ø–Ω—ç–Ω –∑”©–≤, —à–∞–ª–≥–∞–≥–¥—Å–∞–Ω —ç—Ö —Å—É—Ä–≤–∞–ª–∂ –±–∞–π—Ö–≥“Ø–π –±–æ–ª —Ç–∞–∞–º–∞–≥ –±“Ø“Ø –æ—Ä—É—É–ª.
<context>
{context}
</context>`;


        const formattedContext = (conversationHistory || [])
            .map(m => {
                // —Ö—ç—Ä–≤—ç—ç –º–µ—Å—Å–µ–∂ —Ä–æ–ª –º—ç–¥—ç–≥–¥—ç—Ö–≥“Ø–π –±–æ–ª –∞—Å—É—É–ª—Ç/—Ö–∞—Ä–∏—É–ª—Ç–∞–∞—Ä —Ç–∞–∞–º–∞–≥–ª–∞–Ω–∞
                const q = m.question;
                const a = m.answer;
                return `User: ${q}\nAssistant: ${a}`;
            })
            .join('\n---\n');


        const MAX_CONTEXT_CHARS = 20_000;
        const safeContext = formattedContext.length > MAX_CONTEXT_CHARS
            ? formattedContext.slice(-MAX_CONTEXT_CHARS) // —Å“Ø“Ø–ª–∏–π–Ω —Ö—ç—Å–≥–∏–π–≥ –∞–≤–Ω–∞
            : formattedContext;

        const { ChatPromptTemplate, MessagesPlaceholder } = require('@langchain/core/prompts');
        const { createStuffDocumentsChain } = require('langchain/chains/combine_documents');
        const { createRetrievalChain } = require('langchain/chains/retrieval');

        const prompt = ChatPromptTemplate.fromMessages([
            ['system', qaSystemPrompt],
            new MessagesPlaceholder('history'), // üëà —ç–Ω—ç –±–æ–ª ”©–º–Ω”©—Ö —è—Ä–∏–∞–≥ –æ—Ä—É—É–ª–∞—Ö —Ö—ç—Å—ç–≥

            ['human', '{input}'],
        ]);

        const questionAnswerChain = await createStuffDocumentsChain({ llm, prompt });
        const chain = await createRetrievalChain({
            retriever,
            combineDocsChain: questionAnswerChain,

        });

        const chatHistory = [];

        for (const msg of conversationHistory) {
            if (msg.question) {
                chatHistory.push({ role: 'user', content: msg.question });
            }
            if (msg.answer) {
                chatHistory.push({ role: 'assistant', content: msg.answer });
            }
        }

        console.time("Chain invocation time");
        const response = await chain.invoke({ input: query, history: chatHistory });
        console.log(chatHistory);
        console.timeEnd("Chain invocation time");

        console.log('\n--- –•–∞—Ä–∏—É–ª—Ç ---');
        console.log(response.answer);
        console.timeEnd("Total question answering time");
        console.log({ conversation_group_id, qaSystemPrompt })



        return response;
    } catch (err) {
        console.error('‚ùå –ê—Å—É—É–ª–≥–∞ –∞—Å—É—É—Ö–∞–¥ –∞–ª–¥–∞–∞ –≥–∞—Ä–ª–∞–∞:', err.stack || err.message);
        throw err;
    }
}

module.exports = { ingestPdfToVectorDB, askQuestion }